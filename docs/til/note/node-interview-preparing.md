## 호이스팅

### 변수 호이스팅

호이스팅은 스코프를 단위로 동작한다.

- 전역변수는 전역 스코프 선두로 끌어올려진 것처럼 동작.
- 지역 변수는 지역 스코프의 선두로 끌어올려진것처럼 동작.  
  따라서 지역 변수는 함수 전체에서 유효하고 전역변수는 전역 전체에서 유효한것.
  **호이스팅은 변수 선언이 스코프의 선두로 끌어올려진 것처럼 동작하는 자바스크립트 고유의 특징!**

### 함수 호이스팅

함수 선언문으로 정의한 함수는 선언문 이전에 호출 가능. 그러나 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출 불가능. (함수 생성 시점이 다름)
함수 표현식으로 정의한 함수는 변수 호이스팅이 발생하는 것.  
var 키워드를 사용한 변수 선언문과 함수 선언문은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행되어 식별자를 생성.  
(var는 undefined로 평가, 함수 선언문으로 정의한건 함수 호이스팅에 의해 호출 가능.)

## 함수를 사용하는 이유

### 함수 - 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것

- 필요할 때 여러번 호출할 수 있다 : 코드의 재사용
- 코드 중복을 억제하고 재사용성을 높여 유지 보수의 편의성 높이고 실수를 줄임 : 코드의 신뢰성 향상
- 함수는 객체타입의 값이므로, 식별자를 통해 코드의 가독성 향상

**함수는 일급객체다**

## 콜백함수 183

함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 의미.  
콜백함수는 고차 함수에 의해 호출되며 이때 고차함수는 필요에 따라 콜백함수에 인수를 전달할 수 있음.

- 고차 함수 : 매개변수를 통해 함수의 외부에서 콜백함수를 전달받은 함수

콜백함수는 비동기처리(이벤트 처리, Ajax통신, 타이머 함수 등) 에 활용되는 중요한 패턴이다.

## 함수형 프로그래밍 188

순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 사이드이펙트를 최소화해서 불변성을 지향하는 프로그래밍 패러다임

- 순수함수 : 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수. 외부 상태에 의존하지 않고 오로지 매개변수를 통해 함수 내부로 전달된 인수에 의존해 반환값 생성.

```js
var count = 0; // 현재 카운트를 나타내는 상태
// 순수 함수 increase는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.
function increase(n) {
  return ++n;
}
// 순수 함수가 반환한 결과값을 변수에 재할당해서 상태를 변경
count = increase(count);
console.log(count); // 1
count = increase(count);
console.log(count); // 2
```

- 비순수 함수 : 외부 상태에 의존, 외부 상태를 변경하는 사이드이펙트가 존재.

```js
var count = 0; // 현재 카운트를 나타내는 상태: increase 함수에 의해 변화한다.
// 비순수 함수
function increase() {
  return ++count; // 외부 상태에 의존하며 외부 상태를 변경한다.
}
// 비순수 함수는 외부 상태(count)를 변경하므로 상태 변화를 추적하기 어려워진다.
increase();
console.log(count); // 1
increase();
console.log(count); // 2
```

## 스코프 189

- 모든 식별자는 자신이 선언된 위치에 다른 코드가 식별자 자신을 참조할 수 있는 유효범위가 달라진다. 이를 스코프라고 한다. (식별자가 유효한 범위)

### 지역 스코프

코드블록이 아닌 함수에 의해 지역스코프가 생성된다 (함수 몸체 내부에서 만들어지는거니까)

### 동적 스코프

- 함수가 호출되는 시점에 동적으로 상위 스코프가 결정됨

### 렉시컬 스코프 == 정적 스코프 198

```js
var x = 1;
function foo() {
  var x = 10;
  bar();
}
function bar() {
  console.log(x);
}
```

자바스크립트는 렉시컬 스코프를 따른다. 어디서 호출했는지가 아니라 함수를 **어디서 정의**했는지에 따라 상위 스코프를 결정한다. 즉, 함수 상위 스코프는 언제나 자신이 정의된 스코프다.

렉시컬 환경의 “외부 렉시컬 환경에 대한 참조”에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정된다. 이것이 바로 렉시컬 스코프다.

## 변수의 생명주기 200

- 전역변수의 변수 선언은 선언문이 어디에 있든 상관없이 가장 먼저 실행된다 (변수 호이스팅)
- 지역 변수의 생명주기는 함수의 생명주기와 일치.
  - 함수가 종료되면 함수가 생성한 스코프도 소멸한다, 단 스코프를 참조하는 부분이 있다면 계속 지속됨. **(클로저)**

* 전역변수의 생명주기. 딱히 명시적 호출이 없이 실행되기 때문에 특별한 진입점이 없고 코드가 로드되자마자 곧바로 해석되고 실행된다.
* var로 선언한 전역변수의 생명주기는 전역 객체의 생명주기와 일치한다.

### 전역변수의 문제

- 암묵적 결합 : 상태 변경 위험성 높음
- 긴 생명주기 : 메모리 리소스도 오래 소비
- 스코프 체인 상에서 종점 존재 : 전역변수가 가장 마지막으로 검색되기 때문 검색 속도가 가장 느리다.
- 네임스페이스 오염

억제하려면? -> 지역변수 써… 변수 스코프는 좁을수록 좋으니깐….

- 즉시실행 함수 `(function () { }());` 이런거 쓰면 지역변수 되잖아
- 네임스페이스 객체 - 전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역변수처럼 사용하고 싶은 변수를 프로퍼티로 추가
- 모듈 패턴 : 클로저를 기반으로 동작, 전역변수 억제는 물론 캡슐화까지 구현 가능

## var, let, const 키워드 218

### var 키워드

문제점

- 변수 중복 선언 허용
- 함수 레벨 스코프 : 전역 변수가 중복 선언되는 경우가 발생
- 변수 호이스팅 : var 로 선언한 변수는 변수 선언문 이전에 참조할 수 있음. 그치만 undefined를 내뱉고, 프로그램의 흐름을 망친다.

### let 키워드

개선점

- 변수 중복 선언 금지
- 블록 레벨 스코프
- 변수 호이스팅 : 선언문 이전에 참조하면 referenceError 발생.(이부분을 일시적 사각지대 TDZ 라고 부름) "선언"과 "초기화"가 분리되어 진행되기 때문

### const 키워드

상수를 선언하기 위해 사용.

- 선언과 동시에 초기화 해야 함.
- 재할당 금지
- const 키워드로 선언된 변수에 객체를 할당한 경우에는 값 변경 가능

### var vs. let vs. const

- 재할당이 필요하면 `let`. 변수 스코프는 최대한 좁게
- 읽기전용의 재할당이 필요없는 상수와 객체에는 `const`.

## 일급객체 249

1. 무명의 리터럴로 생성 가능. 즉 런타임에 생성 가능
2. 변수나 자료구조에 저장 가능
3. 함수의 매개변수에 전달 가능
4. 함수의 반환값으로 사용 가능

위 네 가지 조건을 만족하면 일급 객체라고 부름. (예를 들어 함수)  
가장 큰 특징은 일반 객체와 같이 함수의 매개변수에 전달할 수 있으며, 함수의 반환값으로 사용할 수 있다는 점.

## 프로토타입 259

자바스크립트는 객체 기반의 프로그래밍 언어이며, 자바스크립트를 이루고 있는 거의 모든것이 객체다. (원시타입 제외)  
프로토타입은 어떤 객체의 상위 객체 역할을 하는 객체로 다른 객체에 공유 프로퍼티(메소드 포함)를 제공.
모든 객체는 하나의 프로토타입을 갖는다. 그리고 모든 프로토타입은 생성자 함수와 연결되어 있다.

- `__proto__` 접근자 프로퍼티로 접근 가능.
  - 해당 접근자 프로퍼티는 상속을 통해 사용된다
  - 왜냐? 프로토타입 체인이 생성되는걸 방지하려고. (서로가 자신의 프로토타입이 되어버릴 수 있잖아요)
- `__proto__` 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 권장되지 않는다.

- 화살표 함수와 ES6 메소드 축약 표현으로 정의한 메소드는 prototype 프로퍼티가 없고, 프로토타입도 생성하지 않음.

### \***\*proto\*\*** vs. prototype

\***\*proto\*\*** 접근자 프로퍼티

- 모든 객체가 갖고 있음
- 객체가 자신의 프로토타입에 접근 또는 교체하기 위해 사용

**prototype** 프로퍼티

- constructor가 갖고 있음
- 생성자 함수가 자신이 생성할 객체의 프로토타입을 할당하기 위해 사용

## 객체지향 프로그래밍 260

프로그램을 여러개의 독립적 단위, 즉 객체의 집합으로 표현하려는 프로그래밍 패러다임

- 추상화 : 다양한 속성 중 프로그램에 필요한 속성만 간추려 내어 표현하는 것
- 객체 : 속성을 통해 여러개의 값을 하나의 단위로 구성한 복합적인 자료구조

객체지향 프로그래밍은 객체의 상태를 나타내는 데이터와, 상태 데이터를 조작할 수 있는 동작을 하나의 논리적인 단위로 묶어 생각한다. 따라서 객체는 상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료구조.

## 상속과 프로토타입

자바스크립트는 프로토타입을 기반으로 상속을 구현한다.

## strict mode 313

ES5부터 추가!
ESLint 써도 유사한 효과를 얻을 수 있음. 정적 분석 기능을 통해 문법적 오류 뿐만 아니라 잠재적 오류까지 찾아내어 오류의 원인을 리포팅 해줌.

strict mode가 감지해주는 것들

- 암묵적 전역 : 선언하지 않은 변수를 참조하면 ReferenceError가 발생
- 변수, 함수, 매개변수의 삭제 : delete 연산자로 변수, 함수, 매개변수를 삭제하면 SyntaxError가 발생
- 매개변수 이름의 중복

## this 키워드 342

메소드가 자신이 속한 객체의 프로퍼티를 참조하려면, 먼저 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 한다.
this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기참조 변수이다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.

### 함수호출 방식 - this 바인딩

this 바인딩은 함수 호출 방식에 의해 동적으로 결정됨.

- this 바인딩은 함수 호출 시점에 결정
  - 일반 함수 호출 : 전역 객체가 바인딩
  - 메서드 호출 : 메소드를 호출한 객체에 바인딩
  - 생성자 함수 호출 : 생성자 함수가 미래에 생성할 인스턴스가 바인딩
  - Function.prototype.apply/call/bind 메소드에 의한 간접호출 : 해당 메소드에 첫번째 인수로 전달한 객체

## 클로저 389

함수를 일급 객체로 취급하는 함수형 프로그래밍 언어에서 사용되는 중요한 특성

외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저closure라고 부른다. 클로저는 중첩 함수가 상위 스코프의 식별자를 참조하고 있고 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정하는 것이 일반적이다.

클로저에 의해 참조되는 상위 스코프 변수를 자유 변수라고 부른다. 클로저란 "함수가 자유변수에 대해 닫혀있다"라는 의미다. 클로저는 상위 스코프를 기억해야하므로 불필요한 메모리의 점유를 걱정할 수 있다.모던 자바스크립트 엔진은 최적화가 잘 되어있어서 클로저가 참조하고 있지 않는 식별자는 기억하지 않는다.

```js
// 카운트 상태 변경 함수
const increase = (function() {
  // 카운트 상태 변수
  let num = 0;
  // 클로저
  return function() {
    // 카운트 상태를 1만큼 증가시킨다.
    return ++num;
  };
})();
console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```

- 클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다 - 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용

## 클래스 417

ES6에 도입!
클래스는 함수다. 일급객체다. 새로운 객체 생성 매커니즘이다.

클래스도 호이스팅이 발생하긴 해. 그치만 선언문 이전에 let이나 const 키워드처럼 TDZ에 빠져서 호이스팅이 발생하지 않는 것처럼 보일 뿐...

## ES6함수 추가 기능 469

### 함수

ES6 이전의 모든 함수는 일반 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수 있었다. (callable이면서 constructor)
ES6 함수의 구분

- 일반함수
- 메서드
- 화살표 함수

### 메서드

ES6 사양에서 메서드는 메서드 축약 표현으로 정의된 함수만을 의미. 인스턴스를 생성할 수 없는 non-consturctor.  
따라서 prototype 프로퍼티가 없고 프로토타입도 생성하지 않는다.
ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부슬롯 [[HomeObject]] 를 갖는다. super 키워드 사용 가능.

### 화살표 함수

화살표 함수는 콜백함수 내부에서 this가 전역 객체를 가리키는 문제를 해결하기 위한 대안으로 유용

- 화살표 함수는 인스턴스를 생성할 수 없는 non-constructor 다.
- 중복된 매개변수 이름을 선언할 수 없다.
- 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않는다.
- 함수 자체에 this 바인딩을 갖지 않는다. 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 참조한다. (렉시컬 this)

### Rest 파라미터 (...rest)

Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다.

### 스프레드 문법

하나로 뭉쳐있는 여러값들의 집합을 펼쳐서 개별적인 값들의 목록으로 받는다.  
(Array, String, Map, Set, DOM 컬렉션, arguments와 같이 for..of 문으로 순회할 수 있는 이터러블에 한정)

### 매개변수 기본값

## 이터러블 614

순회 가능한 콜렉션

## 디스트럭처링 할당 636

구조분해 할당. 구조화된 배열과 같은 이터러블 또는 객체를 비구조화 하여 1개 이상의 변수에 개별적으로 할당하는 것. 배열과 같은 이터러블 또는 객체 리터럴에서 필요한 값만 추출하여 변수에 할당할 때 유용하다.

## Set

중복되지 않는 유일한 값들의 집합. 배열과 유사하지만,

- 중복값 포함 불가
- 요소 순서에 의미 없음
- 인덱스로 요소에 접근 불가

## Map

Map 객체는 키와 값이 쌍으로 이루어진 컬렉션이다. 객체와 유사하지만,

- 키로 사용할 수 있는 값이 객체를 포함한 모든 값이 되며
- 이터러블 하며
- 요소 개수를 `map.size`로 할 수 있다.

## 브라우저 렌더링 과정 661

1. 브라우저는 렌더링에 필요한 리소스를 요청하고 서버로부터 응답을 받는다.
2. 브라우저 렌더링 엔진은 서버로부터 응답된 HTML과 CSS를 파싱하여 DOM과 CSSOM을 생성하고 이들을 결합하여 렌더 트리를 생성
3. 브라우저의 자바스크립트 엔진은 서버로 응답된 자바스크립트를 파싱하여 AST를 생성, 바이트코드로 변환하여 실행. 이 때 자바스크립트는 DOM API를 통해 DOM이나 CSSOM 변경 가능. 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합된다.
4. 렌더 트리를 기반으로 HTML 요소의 레이아웃(위치와 크기)을 계산하고 브라우저에 HTML 요소를 페인팅한다.

## 타이머 800

## 비동기 프로그래밍 809

자바스크립트엔진은 단 하나의 실행 컨텍스트 스택을 갖는다. 한번에 하나의 태스크만 실행할 수 있는 싱글 스레드 방식.
처리에 시간이 걸리는 태스크를 실행하는 경우 블로킹(작업 중단)이 발생한다.  
태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식을 비동기처리라고 한다.

## 이벤트 루프와 태스크 큐

### 자바스크립트 엔진의 2개 영역

![eventloop-browserenvirionment](~@img/node-interview-preparing/eventloop.png)

#### 콜스택

소스코드 평가 과정에서 생성된 실행 컨텍스트가 추가되고 제거되는 스택 자료구조인 실행컨텍스트 스택 = 콜스택
함수를 호출하면 함수 실행 컨텍스트가 순차적으로 콜 스택에 푸시되어 순차적으로 실행된다. 최상위 실행 컨텍스트(실행중인 실행 컨텍스트)가 종료되어 콜스택에서 제거 되기 전까지는 다른 어떤 태스크도 실행되지 않는다.

#### 힙

객체가 저장되는 메모리 공간. 콜스택의 요소인 실행 컨텍스트는 힙에 저장된 객체를 참조한다.  
메모리에 값을 저장하려면 먼저 값을 저장할 메모리 공간의 크기를 결정해야 한다. 객체는 원시 값과는 달리 크기가 정해져있지 않으므로, 할당해야할 메모리 공간의 크기를 런타임에 결정(동적 할당)해야 한다. 따라서 객체가 저장되는 메모리 공간인 힙은 구조화 되어 있지 않다는 특징

### 구동 원리

자바스크립트 엔진은 단순히 태스크가 요청되면 콜스택을 통해 요청된 작업을 순차적으로 실행.
비동기 처리에서 소스코드의 평가와 실행을 제외한 모든 처리는 자바스크립트 엔진을 구동하는 환경인 브라우저 또는 Node.js가 담당한다.

#### 태스크 큐 (이벤트 큐, 콜백 큐)

비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역.  
프로미스의 후속처리 메소드의 콜백 함수가 일시적으로 보관되는 마이크로태스크 큐라는 것도 있음.

#### 이벤트 루프

콜 스택에 현재 실행중인 실행 컨텍스트가 있는지, 그리고 태스크 큐에 대기중인 함수(콜백함수, 이벤트 핸들러 등)가 있는지 반복해서 확인.  
만약 콜스택이 비어있고 태스크 큐에 대기중인 함수가 있다면 이벤트 루프는 순차적FIFO으로 태스크 큐에 대기중인 함수를 콜스택으로 이동시킨다. 콜스택으로 이동한 함수는 실행된다. 즉, 태스크 큐에 일시 보관된 함수들은 비동기 처리 방식으로 동작한다.

## Ajax 816

자바스크립트를 사용하여 브라우저가ㅓ 서버에게 비동기 방식으로 데이터를 요청하고 서버가 응답한 데이터를 수신하여 웹페이지를 동적으로 갱신하는 프로그래밍 방식.
`XMLHttpRequest`는 HTTP 비동기 통신을 위한 메서드와 프로퍼티를 제공한다.

## REST API 830

## 프로미스 842

### 콜백 패턴의 단점

- 콜백 헬

  - 콜백 함수를 통해 비동기 처리 결과에 대한 후속 처리를 수행하는 비동기 함수가 비동기 처리 결과를 가지고 또다시 비동기 함수를 호출해야 한다면 콜백 함수 호출이 중첩되어 복잡도가 높아지는 현상

- 에러 처리의 한계
  - `try...catch...` 를 사용이 안 됨
  - 비동기 함수를 실행하면 실행 컨텍스트가 생성되어 콜 스택에 푸시되어 실행. 비동기 함수는 콜백 함수가 호출되는 것을 기다리지 않고 즉시 종료되어 콜 스택에서 제거 된다. 비동기 함수가 완료 되면 그제서야 태스크 큐로 푸쉬되고 콜스택이 비어졌을 때 이벤트 루프에 의해 콜스택으로 푸쉬되어 실행된다. 에러는 호출자 방향으로 전파되는데, 비동기 함수의 콜백함수를 호출한것은 비동기 함수자체가 아니기 때문에 catch 블록에서 캐치되지 않는다.

### 프로미스

프로미스 생성자 함수가 인수로 전달받은 콜백 함수 내부에서 비동기 처리를 수행한다. 비동기 처리가 성공하면 콜백 함수의 인수로 받은 resolve 함수를 호출하고, 비동기 처리가 실패하면 reject함수를 호출한다.

- 비동기처리 성공 : resolve 함수 호출하여 프로미스를 fulfilled 상태로 변경
- 비동기처리 실패 : reject 함수 호출하여 프로미스를 rejected 상태로 변경

### 프로미스의 에러처리

- 비동기 처리 결과에 대한 후속처리는 프로미스가 제공하는 후속처리 메서드 then, catch, finally를 사용하여 수행한다.

프로미스 체이닝으로 콜백헬 처리. 하지만 콜백패턴은 계속된다.....
ES8에서 도입된 async / await 를 통해 해결 가능!

## 제너레이터와 async /await 868

### 제너레이터

코드 블록의 실행을 일시 중지했다가 필요한 시점에 재개할 수 있는 특수한 함수.  
하나 이상의 yield 표현식을 포함한다.  
이터러블 이면서 이터레이터이다.
`function*` 와 같이 사용

```js
// 제너레이터 함수 선언문
function* genDecFunc() {
yield 1;
}
// 제너레이터 함수 표현식
const genExpFunc = function* () {
yield 1;
};
// 제너레이터 메서드
const obj = {
* genObjMethod() {
yield 1;
}
};
// 제너레이터 클래스 메서드
class MyClass {
* genClsMethod() {
yield 1;
```

yield 키워드는 제너레이터 함수의 실행을 일시중지시키거나, yield 키워드 뒤에 오는 표현식의 평가 결과를 제너레이터 함수 호출자에게 반환함.

`.next()`로 다음 yield까지 진행

### async / await

프로미스 기반. 프로미스의 then/catch/finally 콜백 함수 전달 필요 없이, 동기처리 처럼 프로미스 사용 가능

**에러는 호출자caller 방향으로 전파**
`try...catch` 사용 가능. 콜백 함수를 인수로 전달받는 비동기 함수와는 달리, 프로미스를 반환하는 비동기 함수는 명시적으로 호출할 수 있기 때문에 호출자가 명확하다.

## 에러처리 884

## 모듈 891

애플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드 조각을 의미. 자신만의 파일스코프를 가질 수 있어야 함.  
모듈은 공개가 필요한 자산에 한정하여 명시적으로 선택적 공개가 가능하다. 이를 `export`라 한다.  
모듈 사용자는 모듈이 공개export한 자산 중 일부 또는 전체를 선택해 자신의 스코프 내로 불러들여 재사용 가능. 이를 `import`라 한다.
