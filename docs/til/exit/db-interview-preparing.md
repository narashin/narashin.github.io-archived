---
title: 면접 준비 - DB
description: 면접 준비 - DB
sidebarDepth: 2
---

## RDBMS / NoSQL 차이

### RDBMS

관계형 데이터베이스. 테이블이 다른 테이블과 관계를 맺고 모여있는 집합체.
외래키를 이용하며 이를 이용해, Join을 할 수 있다.

- 명확한 데이터 구조를 보장한다.
- 관계는 각 데이터를 중복없이 한번만 저장할 수 있다.

그러나,

- 테이블간 관계가 복잡해질 경우 JOIN이 많은 복잡한 쿼리가 만들어짐.
- Scale-UP만 가능
- 스키마로 인해, 데이터가 유연하지 못하다. 최초 설계를 잘해야함.

### NoSQL

테이블 간 관계를 정의하지 않는다. Join도 불가.

- Key-value database : DynamoDB, Redis
- Document database : MongoDB, DocumentDB

- 스키마가 없기 때문에 유연하며, 자유로운 데이터 구조를 가질 수 있음. 언제든 저장된 데이터를 조정하고 새로운 필드를 추가할 수 있음.
- 데이터 분산이 용이하며 성능 향상을 위한 Scale-up 뿐만 아니라 Scale-out도 가능

그러나,

- 데이터 중복 발생 가능
- 스키마가 존재하지 않기 때문에 명확한 데이터 구조를 보장하지 않음.

## join의 종류

### Inner join

교집합

### Left outer join

### Right outer join

### Full outer join

합집합

## select, from, where, group by, order by. having 의 실행 순서

FROM - WHERE - GROUP BY - HAVING - SELECT - ORDERBY

## 실행 계획이란? (execution plan)

사용자가 SQL을 실행하여 데이터를 추출하려고 할 때 옵티마이저가 수립하는 작업절차를 뜻한다.

1. SQL 해석
2. 실행계획 수립
3. 실행

## index 란?

데이터 테이블의 검색 속도를 향상 시키기 위한 자료구조.

SELECT 쿼리의 성능을 월등히 향상시키는 INDEX 항상 좋은 것일까? 쿼리문의 성능을 향상시킨다는데, 모든 컬럼에 INDEX 를 생성해두면 빨라지지 않을까? 결론부터 말하자면 그렇지 않다. 우선, 첫번째 이유는 INDEX 를 생성하게 되면 INSERT, DELETE, UPDATE 쿼리문을 실행할 때 별도의 과정이 추가적으로 발생한다. INSERT 의 경우 INDEX 에 대한 데이터도 추가해야 하므로 그만큼 성능에 손실이 따른다. DELETE 의 경우 INDEX 에 존재하는 값은 삭제하지 않고 사용 안한다는 표시로 남게 된다. 즉 row 의 수는 그대로인 것이다. 이 작업이 반복되면 어떻게 될까?

### b-tree는 db에서 어떻게 이용되나

왜 index 를 생성하는데 b-tree 를 사용하는가?
데이터에 접근하는 시간복잡도가 O(1)인 hash table 이 더 효율적일 것 같은데? SELECT 질의의 조건에는 부등호(<>) 연산도 포함이 된다. hash table 을 사용하게 된다면 등호(=) 연산이 아닌 부등호 연산의 경우에 문제가 발생한다. 동등 연산(=)에 특화된 hashtable은 데이터베이스의 자료구조로 적합하지 않다.

## 정규화 반정규화란?

### 정규화

관계형 데이터베이스에서 중복을 최소화하기위해 데이터를 구조화 하는 작업. 하나의 종속성이 하나의 릴레이션에 표현될 수 있도록 분해해가는 과정

#### 정규화의 원칙

1. 정보 무손실의 원칙 - 하나의 스키마를 다른 스키마로 변환할 때 정보 손실이 있어서는 안된다.
2. 분리의 원칙 - 하나의 독립된 관계성은 하나의 독립된 릴레이션으로 분리시켜 표현해야 한다.
3. 데이터 중복성이 감소되어야 한다.

### 반정규화

하나 이상의 테이블에 데이터를 중복해 배치하는 최적화 기법. 의도적으로 정규화 원칙을 위배하는 행위.

- 조인 비용이 줄어들어 빠른 데이터 조회 가능
- 살펴볼 테이블이 줄어들어 데이터 조회 쿼리가 간단해짐

그러나,

- 데이터 갱신이나 삽입 비용이 높음
- 데이터 갱신 또는 삽입 코드를 작성하기 어려워짐
- 데이터 간 일관성을 깨질 위험
- 데이터를 중복해서 저장하므로 더 많은 저장공간 필요

## DB Connection Pool 이란?

DB Connection Pool 매니저가 일정의 커넥션을 연결하고 있다가, 요청이 들어오면 커넥션을 할당해주고 없으면 기다리게 한다. 요청한 클라이언트가 커넥션을 다 쓰면 반납하는 구조.  
사용자가 요청할 때마다 매번 DB 객체를 생성, 연결, 종료하기 때문에 비효율적이라 이를 이용함.

## transaction 이란?

데이터의 완전성을 보장하기 위해, 데이터베이스의 상태를 변화시키기 위해서 수행하는 작업의 단위를 뜻한다. "쪼개질 수 없는 업무처리의 단위"

## lock 의 종류와 그에 대한 설명

Lock이란 트랜잭션 처리의 순차성을 보장해주는 기능을 제공한다. Lock은 하나의 트랜잭션이 완벽하게 끝날 때까지 다른 요청을 막는다.

### Shared Lock - Read Lock

데이터를 읽을 때 사용되는 Lock. Read Lock 끼리는 동시에 접근이 가능하다. 데이터 일관성과 무결성을 해치지 않기 때문임. (변경없이 오직 읽기 작업만)  
Exclusive Lock의 접근을 막는다.

### Exclusive Lock - Write Lock

데이터를 변경할 때 사용되는 Lock. Exclusive Lock이 끝날 때까지 어떠한 접근도 허용하지 않는다. 이 Lock은 다른 트랜잭션이 수행되고 있는 데이터에 대해서 접근하여 Lock을 걸 수 없다.

### Block

Lock간 결합. 특정 트랜잭션이 끝나지 않아 Lock이 걸린 상태로 멈춰있는 상태를 의미. Exclusive - Exclusive 나 Shared- Exclusive끼리 블로킹이 발생할 수 있음. 이 경우 Transaction commit 또는 rollback을 사용해야 한다.

- SQL문이 복잡하면 리팩토링 하여 실행 속도를 올리기
- 트랜잭션 처리 시간이 짧으면 경합을 줄일 수 있음
- 동일 데이터를 동시에 변경하는 작업을 배제
- lock_timeout 설정을 통해 Lock 최대 시간을 지정

## deadlock 이 발생하는 상황

Blocking보다 심한 교착 상태로, 두 트랜잭션이 각각 Lock을 설정하고, 서로의 Lock에 접근하여 값을 얻어오려고 할 때 서로의 Lock으로 인해 양쪽 트랜잭션이 영원히 처리되지 않는 상태를 말한다.

- 둘 중 하나의 트랜잭션을 강제 종료
- 접근 순서 규칙 지정

## sql injection?

SQL Injection 이란 악의적인 사용자가 보안상의 취약점을 이용하여, 임의의 SQL 문을 주입하고 실행되게 하여 데이터베이스가 비정상적인 동작을 하도록 조작하는 행위 입니다

## db 셀렉트시 락걸렸을때 해결 방법

---

# Do It! 오라클로 배우는 데이터 입문

## 효율적인 데이터 관리를 위한 조건

- 데이터를 통합하여 관리
- 일관된 방법으로 관리
- 데이터 누락 및 중복 제거
- 여러 사용자가 공동으로 실시간 사용 가능

## 데이터 모델

### 계층형 데이터 모델

- 트리 구조
  하나의 부모 개체가 여러 자식을 가질 수 있다. (반면 자식개체는 여러 부모 개체를 가질 수 없다.)
  일대다 구조의 데이터를 표현하기에는 알맞지만 자식 개체가 여러 부모를 가진 관계는 표현할 수 없다.

### 네트워크형 데이터 모델

- 망형 데이터 모델, 그래프 구조 기반
  개체간 관계를 그래프 구조로 연결하므로 자식개체가 여러 부모 개체를 가질 수 있음.

### 객체 지향형 데이터 모델

### 관계형 데이터 모델

- 개체, 테이블
- 속성, 열
- 관계, 외래키

독립성, 무결성과 같은 데이터 아전하게 관리하기 위한 필요 개념들을 정의

## 열, 키

- 기본키 : 테이블 내에서 중복되지 않는 값만 가질 수 있는 키(ex 학번)
- 후보키 : 기본키가 될 수 있는 모든 키를 의미
  - 보조키 : 후보키 중 기본키로 지정되지 않은 열
- 외래키 : 특정 테이블에 포함되어 있으면서 다른 테이블의 기본키로 지정된 키 (ex 학과코드)
- 복합키 : 여러 열을 조합하여 기본키 역할을 할 수 있게 만든 키

## 트랜잭션

- 더이상 분할할 수 없는 최소 수행 단위를 뜻함.

### 트랜잭션을 취소하고 싶을 때는 ROLLBACK

### 트랜잭션을 영원히 반영하고 싶을 때는 COMMIT

## 세션과 읽기 일관성의 의믜

세션이 트랜잭션보다 더 큰 범위. (세션 내붕 하나 이상의 트랜잭션이 존재.)  
데이터 베이스에 접속한 후 종료하기까지의 과정이 하나의 세션

### 읽기 일관성의 중요성

어떤 데이터 조작이 포함된 트랜잭션이 완료(롤백, 커밋)되기 전까지 데이터를 직접 조작하는 세션 외 다른 세션에서는 데이터 조작 전 상태의 내용이 일관적으로 조회, 출력, 검색되는 특성을 뜻한다.

## 수정 중인 데이터의 접근을 막는 LOCK

특정 세션에서 조작중인 데이터는 트랜잭션이 완료 되기 전까지 다른 세션에서 조작할 수 없는 상태가 된다. LOCK이 된다는 것이지요. LOCK은 조작중인 데이터를 다른 세션은 조작할 수 없도록 접근을 보류시킨다.

- 특정 세션에서 데이터 조작이 완료될 때까지 다른 세션에서 해당 데이터 조작을 기다리는 현상을 HANG(행)이라고 한다.

### LOCK 종류

데이터 조작 명령어를 사용하여 데이터가 변경 중인 테이블은 테이블 단위 잠금이라는 의미로 '테이블 레벨 록'이 걸리게 된다.
