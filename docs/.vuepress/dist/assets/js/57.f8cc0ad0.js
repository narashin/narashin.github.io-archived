(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{550:function(a,t,v){"use strict";v.r(t);var r=v(25),_=Object(r.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h2",{attrs:{id:"rdbms-nosql-차이"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#rdbms-nosql-차이"}},[a._v("#")]),a._v(" RDBMS / NoSQL 차이")]),a._v(" "),v("h3",{attrs:{id:"rdbms"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#rdbms"}},[a._v("#")]),a._v(" RDBMS")]),a._v(" "),v("p",[a._v("관계형 데이터베이스. 테이블이 다른 테이블과 관계를 맺고 모여있는 집합체.\n외래키를 이용하며 이를 이용해, Join을 할 수 있다.")]),a._v(" "),v("ul",[v("li",[a._v("명확한 데이터 구조를 보장한다.")]),a._v(" "),v("li",[a._v("관계는 각 데이터를 중복없이 한번만 저장할 수 있다.")])]),a._v(" "),v("p",[a._v("그러나,")]),a._v(" "),v("ul",[v("li",[a._v("테이블간 관계가 복잡해질 경우 JOIN이 많은 복잡한 쿼리가 만들어짐.")]),a._v(" "),v("li",[a._v("Scale-UP만 가능")]),a._v(" "),v("li",[a._v("스키마로 인해, 데이터가 유연하지 못하다. 최초 설계를 잘해야함.")])]),a._v(" "),v("h3",{attrs:{id:"nosql"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#nosql"}},[a._v("#")]),a._v(" NoSQL")]),a._v(" "),v("p",[a._v("테이블 간 관계를 정의하지 않는다. Join도 불가.")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("Key-value database : DynamoDB, Redis")])]),a._v(" "),v("li",[v("p",[a._v("Document database : MongoDB, DocumentDB")])]),a._v(" "),v("li",[v("p",[a._v("스키마가 없기 때문에 유연하며, 자유로운 데이터 구조를 가질 수 있음. 언제든 저장된 데이터를 조정하고 새로운 필드를 추가할 수 있음.")])]),a._v(" "),v("li",[v("p",[a._v("데이터 분산이 용이하며 성능 향상을 위한 Scale-up 뿐만 아니라 Scale-out도 가능")])])]),a._v(" "),v("p",[a._v("그러나,")]),a._v(" "),v("ul",[v("li",[a._v("데이터 중복 발생 가능")]),a._v(" "),v("li",[a._v("스키마가 존재하지 않기 때문에 명확한 데이터 구조를 보장하지 않음.")])]),a._v(" "),v("h2",{attrs:{id:"join의-종류"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#join의-종류"}},[a._v("#")]),a._v(" join의 종류")]),a._v(" "),v("h3",{attrs:{id:"inner-join"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#inner-join"}},[a._v("#")]),a._v(" Inner join")]),a._v(" "),v("p",[a._v("교집합")]),a._v(" "),v("h3",{attrs:{id:"left-outer-join"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#left-outer-join"}},[a._v("#")]),a._v(" Left outer join")]),a._v(" "),v("h3",{attrs:{id:"right-outer-join"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#right-outer-join"}},[a._v("#")]),a._v(" Right outer join")]),a._v(" "),v("h3",{attrs:{id:"full-outer-join"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#full-outer-join"}},[a._v("#")]),a._v(" Full outer join")]),a._v(" "),v("p",[a._v("합집합")]),a._v(" "),v("h2",{attrs:{id:"select-from-where-group-by-order-by-having-의-실행-순서"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#select-from-where-group-by-order-by-having-의-실행-순서"}},[a._v("#")]),a._v(" select, from, where, group by, order by. having 의 실행 순서")]),a._v(" "),v("p",[a._v("FROM - WHERE - GROUP BY - HAVING - SELECT - ORDERBY")]),a._v(" "),v("h2",{attrs:{id:"실행-계획이란-execution-plan"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#실행-계획이란-execution-plan"}},[a._v("#")]),a._v(" 실행 계획이란? (execution plan)")]),a._v(" "),v("p",[a._v("사용자가 SQL을 실행하여 데이터를 추출하려고 할 때 옵티마이저가 수립하는 작업절차를 뜻한다.")]),a._v(" "),v("ol",[v("li",[a._v("SQL 해석")]),a._v(" "),v("li",[a._v("실행계획 수립")]),a._v(" "),v("li",[a._v("실행")])]),a._v(" "),v("h2",{attrs:{id:"index-란"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#index-란"}},[a._v("#")]),a._v(" index 란?")]),a._v(" "),v("p",[a._v("데이터 테이블의 검색 속도를 향상 시키기 위한 자료구조.")]),a._v(" "),v("p",[a._v("SELECT 쿼리의 성능을 월등히 향상시키는 INDEX 항상 좋은 것일까? 쿼리문의 성능을 향상시킨다는데, 모든 컬럼에 INDEX 를 생성해두면 빨라지지 않을까? 결론부터 말하자면 그렇지 않다. 우선, 첫번째 이유는 INDEX 를 생성하게 되면 INSERT, DELETE, UPDATE 쿼리문을 실행할 때 별도의 과정이 추가적으로 발생한다. INSERT 의 경우 INDEX 에 대한 데이터도 추가해야 하므로 그만큼 성능에 손실이 따른다. DELETE 의 경우 INDEX 에 존재하는 값은 삭제하지 않고 사용 안한다는 표시로 남게 된다. 즉 row 의 수는 그대로인 것이다. 이 작업이 반복되면 어떻게 될까?")]),a._v(" "),v("h3",{attrs:{id:"b-tree는-db에서-어떻게-이용되나"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#b-tree는-db에서-어떻게-이용되나"}},[a._v("#")]),a._v(" b-tree는 db에서 어떻게 이용되나")]),a._v(" "),v("p",[a._v("왜 index 를 생성하는데 b-tree 를 사용하는가?\n데이터에 접근하는 시간복잡도가 O(1)인 hash table 이 더 효율적일 것 같은데? SELECT 질의의 조건에는 부등호(<>) 연산도 포함이 된다. hash table 을 사용하게 된다면 등호(=) 연산이 아닌 부등호 연산의 경우에 문제가 발생한다. 동등 연산(=)에 특화된 hashtable은 데이터베이스의 자료구조로 적합하지 않다.")]),a._v(" "),v("h2",{attrs:{id:"정규화-반정규화란"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#정규화-반정규화란"}},[a._v("#")]),a._v(" 정규화 반정규화란?")]),a._v(" "),v("h3",{attrs:{id:"정규화"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#정규화"}},[a._v("#")]),a._v(" 정규화")]),a._v(" "),v("p",[a._v("관계형 데이터베이스에서 중복을 최소화하기위해 데이터를 구조화 하는 작업. 하나의 종속성이 하나의 릴레이션에 표현될 수 있도록 분해해가는 과정")]),a._v(" "),v("h4",{attrs:{id:"정규화의-원칙"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#정규화의-원칙"}},[a._v("#")]),a._v(" 정규화의 원칙")]),a._v(" "),v("ol",[v("li",[a._v("정보 무손실의 원칙 - 하나의 스키마를 다른 스키마로 변환할 때 정보 손실이 있어서는 안된다.")]),a._v(" "),v("li",[a._v("분리의 원칙 - 하나의 독립된 관계성은 하나의 독립된 릴레이션으로 분리시켜 표현해야 한다.")]),a._v(" "),v("li",[a._v("데이터 중복성이 감소되어야 한다.")])]),a._v(" "),v("h3",{attrs:{id:"반정규화"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#반정규화"}},[a._v("#")]),a._v(" 반정규화")]),a._v(" "),v("p",[a._v("하나 이상의 테이블에 데이터를 중복해 배치하는 최적화 기법. 의도적으로 정규화 원칙을 위배하는 행위.")]),a._v(" "),v("ul",[v("li",[a._v("조인 비용이 줄어들어 빠른 데이터 조회 가능")]),a._v(" "),v("li",[a._v("살펴볼 테이블이 줄어들어 데이터 조회 쿼리가 간단해짐")])]),a._v(" "),v("p",[a._v("그러나,")]),a._v(" "),v("ul",[v("li",[a._v("데이터 갱신이나 삽입 비용이 높음")]),a._v(" "),v("li",[a._v("데이터 갱신 또는 삽입 코드를 작성하기 어려워짐")]),a._v(" "),v("li",[a._v("데이터 간 일관성을 깨질 위험")]),a._v(" "),v("li",[a._v("데이터를 중복해서 저장하므로 더 많은 저장공간 필요")])]),a._v(" "),v("h2",{attrs:{id:"db-connection-pool-이란"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#db-connection-pool-이란"}},[a._v("#")]),a._v(" DB Connection Pool 이란?")]),a._v(" "),v("p",[a._v("DB Connection Pool 매니저가 일정의 커넥션을 연결하고 있다가, 요청이 들어오면 커넥션을 할당해주고 없으면 기다리게 한다. 요청한 클라이언트가 커넥션을 다 쓰면 반납하는 구조."),v("br"),a._v("\n사용자가 요청할 때마다 매번 DB 객체를 생성, 연결, 종료하기 때문에 비효율적이라 이를 이용함.")]),a._v(" "),v("h2",{attrs:{id:"transaction-이란"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#transaction-이란"}},[a._v("#")]),a._v(" transaction 이란?")]),a._v(" "),v("p",[a._v('데이터의 완전성을 보장하기 위해, 데이터베이스의 상태를 변화시키기 위해서 수행하는 작업의 단위를 뜻한다. "쪼개질 수 없는 업무처리의 단위"')]),a._v(" "),v("h2",{attrs:{id:"lock-의-종류와-그에-대한-설명"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#lock-의-종류와-그에-대한-설명"}},[a._v("#")]),a._v(" lock 의 종류와 그에 대한 설명")]),a._v(" "),v("p",[a._v("Lock이란 트랜잭션 처리의 순차성을 보장해주는 기능을 제공한다. Lock은 하나의 트랜잭션이 완벽하게 끝날 때까지 다른 요청을 막는다.")]),a._v(" "),v("h3",{attrs:{id:"shared-lock-read-lock"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#shared-lock-read-lock"}},[a._v("#")]),a._v(" Shared Lock - Read Lock")]),a._v(" "),v("p",[a._v("데이터를 읽을 때 사용되는 Lock. Read Lock 끼리는 동시에 접근이 가능하다. 데이터 일관성과 무결성을 해치지 않기 때문임. (변경없이 오직 읽기 작업만)"),v("br"),a._v("\nExclusive Lock의 접근을 막는다.")]),a._v(" "),v("h3",{attrs:{id:"exclusive-lock-write-lock"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#exclusive-lock-write-lock"}},[a._v("#")]),a._v(" Exclusive Lock - Write Lock")]),a._v(" "),v("p",[a._v("데이터를 변경할 때 사용되는 Lock. Exclusive Lock이 끝날 때까지 어떠한 접근도 허용하지 않는다. 이 Lock은 다른 트랜잭션이 수행되고 있는 데이터에 대해서 접근하여 Lock을 걸 수 없다.")]),a._v(" "),v("h3",{attrs:{id:"block"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#block"}},[a._v("#")]),a._v(" Block")]),a._v(" "),v("p",[a._v("Lock간 결합. 특정 트랜잭션이 끝나지 않아 Lock이 걸린 상태로 멈춰있는 상태를 의미. Exclusive - Exclusive 나 Shared- Exclusive끼리 블로킹이 발생할 수 있음. 이 경우 Transaction commit 또는 rollback을 사용해야 한다.")]),a._v(" "),v("ul",[v("li",[a._v("SQL문이 복잡하면 리팩토링 하여 실행 속도를 올리기")]),a._v(" "),v("li",[a._v("트랜잭션 처리 시간이 짧으면 경합을 줄일 수 있음")]),a._v(" "),v("li",[a._v("동일 데이터를 동시에 변경하는 작업을 배제")]),a._v(" "),v("li",[a._v("lock_timeout 설정을 통해 Lock 최대 시간을 지정")])]),a._v(" "),v("h2",{attrs:{id:"deadlock-이-발생하는-상황"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#deadlock-이-발생하는-상황"}},[a._v("#")]),a._v(" deadlock 이 발생하는 상황")]),a._v(" "),v("p",[a._v("Blocking보다 심한 교착 상태로, 두 트랜잭션이 각각 Lock을 설정하고, 서로의 Lock에 접근하여 값을 얻어오려고 할 때 서로의 Lock으로 인해 양쪽 트랜잭션이 영원히 처리되지 않는 상태를 말한다.")]),a._v(" "),v("ul",[v("li",[a._v("둘 중 하나의 트랜잭션을 강제 종료")]),a._v(" "),v("li",[a._v("접근 순서 규칙 지정")])]),a._v(" "),v("h2",{attrs:{id:"sql-injection"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#sql-injection"}},[a._v("#")]),a._v(" sql injection?")]),a._v(" "),v("p",[a._v("SQL Injection 이란 악의적인 사용자가 보안상의 취약점을 이용하여, 임의의 SQL 문을 주입하고 실행되게 하여 데이터베이스가 비정상적인 동작을 하도록 조작하는 행위 입니다")]),a._v(" "),v("h2",{attrs:{id:"db-셀렉트시-락걸렸을때-해결-방법"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#db-셀렉트시-락걸렸을때-해결-방법"}},[a._v("#")]),a._v(" db 셀렉트시 락걸렸을때 해결 방법")]),a._v(" "),v("hr"),a._v(" "),v("h1",{attrs:{id:"do-it-오라클로-배우는-데이터-입문"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#do-it-오라클로-배우는-데이터-입문"}},[a._v("#")]),a._v(" Do It! 오라클로 배우는 데이터 입문")]),a._v(" "),v("h2",{attrs:{id:"효율적인-데이터-관리를-위한-조건"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#효율적인-데이터-관리를-위한-조건"}},[a._v("#")]),a._v(" 효율적인 데이터 관리를 위한 조건")]),a._v(" "),v("ul",[v("li",[a._v("데이터를 통합하여 관리")]),a._v(" "),v("li",[a._v("일관된 방법으로 관리")]),a._v(" "),v("li",[a._v("데이터 누락 및 중복 제거")]),a._v(" "),v("li",[a._v("여러 사용자가 공동으로 실시간 사용 가능")])]),a._v(" "),v("h2",{attrs:{id:"데이터-모델"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#데이터-모델"}},[a._v("#")]),a._v(" 데이터 모델")]),a._v(" "),v("h3",{attrs:{id:"계층형-데이터-모델"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#계층형-데이터-모델"}},[a._v("#")]),a._v(" 계층형 데이터 모델")]),a._v(" "),v("ul",[v("li",[a._v("트리 구조\n하나의 부모 개체가 여러 자식을 가질 수 있다. (반면 자식개체는 여러 부모 개체를 가질 수 없다.)\n일대다 구조의 데이터를 표현하기에는 알맞지만 자식 개체가 여러 부모를 가진 관계는 표현할 수 없다.")])]),a._v(" "),v("h3",{attrs:{id:"네트워크형-데이터-모델"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#네트워크형-데이터-모델"}},[a._v("#")]),a._v(" 네트워크형 데이터 모델")]),a._v(" "),v("ul",[v("li",[a._v("망형 데이터 모델, 그래프 구조 기반\n개체간 관계를 그래프 구조로 연결하므로 자식개체가 여러 부모 개체를 가질 수 있음.")])]),a._v(" "),v("h3",{attrs:{id:"객체-지향형-데이터-모델"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#객체-지향형-데이터-모델"}},[a._v("#")]),a._v(" 객체 지향형 데이터 모델")]),a._v(" "),v("h3",{attrs:{id:"관계형-데이터-모델"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#관계형-데이터-모델"}},[a._v("#")]),a._v(" 관계형 데이터 모델")]),a._v(" "),v("ul",[v("li",[a._v("개체, 테이블")]),a._v(" "),v("li",[a._v("속성, 열")]),a._v(" "),v("li",[a._v("관계, 외래키")])]),a._v(" "),v("p",[a._v("독립성, 무결성과 같은 데이터 아전하게 관리하기 위한 필요 개념들을 정의")]),a._v(" "),v("h2",{attrs:{id:"열-키"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#열-키"}},[a._v("#")]),a._v(" 열, 키")]),a._v(" "),v("ul",[v("li",[a._v("기본키 : 테이블 내에서 중복되지 않는 값만 가질 수 있는 키(ex 학번)")]),a._v(" "),v("li",[a._v("후보키 : 기본키가 될 수 있는 모든 키를 의미\n"),v("ul",[v("li",[a._v("보조키 : 후보키 중 기본키로 지정되지 않은 열")])])]),a._v(" "),v("li",[a._v("외래키 : 특정 테이블에 포함되어 있으면서 다른 테이블의 기본키로 지정된 키 (ex 학과코드)")]),a._v(" "),v("li",[a._v("복합키 : 여러 열을 조합하여 기본키 역할을 할 수 있게 만든 키")])]),a._v(" "),v("h2",{attrs:{id:"트랜잭션"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#트랜잭션"}},[a._v("#")]),a._v(" 트랜잭션")]),a._v(" "),v("ul",[v("li",[a._v("더이상 분할할 수 없는 최소 수행 단위를 뜻함.")])]),a._v(" "),v("h3",{attrs:{id:"트랜잭션을-취소하고-싶을-때는-rollback"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#트랜잭션을-취소하고-싶을-때는-rollback"}},[a._v("#")]),a._v(" 트랜잭션을 취소하고 싶을 때는 ROLLBACK")]),a._v(" "),v("h3",{attrs:{id:"트랜잭션을-영원히-반영하고-싶을-때는-commit"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#트랜잭션을-영원히-반영하고-싶을-때는-commit"}},[a._v("#")]),a._v(" 트랜잭션을 영원히 반영하고 싶을 때는 COMMIT")]),a._v(" "),v("h2",{attrs:{id:"세션과-읽기-일관성의-의믜"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#세션과-읽기-일관성의-의믜"}},[a._v("#")]),a._v(" 세션과 읽기 일관성의 의믜")]),a._v(" "),v("p",[a._v("세션이 트랜잭션보다 더 큰 범위. (세션 내붕 하나 이상의 트랜잭션이 존재.)"),v("br"),a._v("\n데이터 베이스에 접속한 후 종료하기까지의 과정이 하나의 세션")]),a._v(" "),v("h3",{attrs:{id:"읽기-일관성의-중요성"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#읽기-일관성의-중요성"}},[a._v("#")]),a._v(" 읽기 일관성의 중요성")]),a._v(" "),v("p",[a._v("어떤 데이터 조작이 포함된 트랜잭션이 완료(롤백, 커밋)되기 전까지 데이터를 직접 조작하는 세션 외 다른 세션에서는 데이터 조작 전 상태의 내용이 일관적으로 조회, 출력, 검색되는 특성을 뜻한다.")]),a._v(" "),v("h2",{attrs:{id:"수정-중인-데이터의-접근을-막는-lock"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#수정-중인-데이터의-접근을-막는-lock"}},[a._v("#")]),a._v(" 수정 중인 데이터의 접근을 막는 LOCK")]),a._v(" "),v("p",[a._v("특정 세션에서 조작중인 데이터는 트랜잭션이 완료 되기 전까지 다른 세션에서 조작할 수 없는 상태가 된다. LOCK이 된다는 것이지요. LOCK은 조작중인 데이터를 다른 세션은 조작할 수 없도록 접근을 보류시킨다.")]),a._v(" "),v("ul",[v("li",[a._v("특정 세션에서 데이터 조작이 완료될 때까지 다른 세션에서 해당 데이터 조작을 기다리는 현상을 HANG(행)이라고 한다.")])]),a._v(" "),v("h3",{attrs:{id:"lock-종류"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#lock-종류"}},[a._v("#")]),a._v(" LOCK 종류")]),a._v(" "),v("p",[a._v("데이터 조작 명령어를 사용하여 데이터가 변경 중인 테이블은 테이블 단위 잠금이라는 의미로 '테이블 레벨 록'이 걸리게 된다.")])])}),[],!1,null,null,null);t.default=_.exports}}]);