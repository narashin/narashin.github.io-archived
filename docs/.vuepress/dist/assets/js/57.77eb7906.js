(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{548:function(t,e,s){"use strict";s.r(e);var _=s(25),r=Object(_.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"_1-http란"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-http란"}},[t._v("#")]),t._v(" 1. HTTP란?")]),t._v(" "),s("p",[t._v("WWW상에서 정보를 주고 받을 수 있는 프로토콜. 주로 TCP를 사용하며, 80번 포트를 사용한다.\nHTTP는 클라이언트와 서버 사이에 이루어지는 요청/응답 프로토콜이다. 주로 HTML 문서를 주고 받는 데에 쓰인다. Stateless.")]),t._v(" "),s("h2",{attrs:{id:"_2-https란"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-https란"}},[t._v("#")]),t._v(" 2. HTTPS란?")]),t._v(" "),s("p",[t._v("HTTPS는 HTTP의 보안이 강화된 버전. 소켓 통신에서 일반 텍스트를 이용하는 대신에, SSL이다 TLS 프로토콜을 통해 세션 데이터를 암호화 한다. 기본 TCP/IP 포트는 443.")]),t._v(" "),s("h2",{attrs:{id:"_3-http1-1과-2-0의-차이"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-http1-1과-2-0의-차이"}},[t._v("#")]),t._v(" 3. HTTP1.1과 2.0의 차이")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://miro.medium.com/max/1328/1*rf2AnDQyHfGO_ThYfb-hWA.png",alt:"1.1과2.0차이"}})]),t._v(" "),s("p",[t._v("HTTP1.1은 연결당 하나의 요청과 응답을 처리하기 때문에 동시 전송 문제와 다수의 리소스를 처리하는 데에 속도, 성능 이슈가 있었음.")]),t._v(" "),s("p",[t._v("HTTP2.0은 한 커넥션에 여러개 메시지를 동시에 주고 받을 수 있으며, 요청 리소스간 의존 관계를 설정할 수 있고, HTML문서상 필요한 리로스를 클라이언트 요청 없이 보내줄 수 있으며, Header정보를 HPACK압축 방식을 이용하여 압축 전송 하여 성능과 속도가 크게 향상.")]),t._v(" "),s("h2",{attrs:{id:"_4-http-응답-코드"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-http-응답-코드"}},[t._v("#")]),t._v(" 4. HTTP 응답 코드")]),t._v(" "),s("p",[t._v("1XX Infomational"),s("br"),t._v("\n2XX Success"),s("br"),t._v("\n3XX Redirection"),s("br"),t._v("\n4XX Client Error"),s("br"),t._v("\n5XX Server Error")]),t._v(" "),s("h2",{attrs:{id:"_5-header"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-header"}},[t._v("#")]),t._v(" 5. Header")]),t._v(" "),s("p",[t._v("인증 Authorization"),s("br"),t._v("\n캐싱 Age, Expires"),s("br"),t._v("\n조건부 Etag, Last-Modified"),s("br"),t._v("\n연결 관리 Connection, Keep-Alive"),s("br"),t._v("\n컨텐츠 협상 Accept,"),s("br"),t._v("\n쿠키 Cookie, Set-Cookie"),s("br"),t._v("\nCORS Access-Control-Allow-Origin, Orgin, Access-Control-Request-Headers, Access-Control-Request-Method"),s("br"),t._v("\n메시지 바디 정보 Content-Type"),s("br"),t._v("\n프록시 Forwarded"),s("br"),t._v("\n요청 컨텍스트 From, Host, Referer, User-Agent"),s("br"),t._v("\n응답 컨텍스트 Allow, Server")]),t._v(" "),s("h2",{attrs:{id:"_4-crud에-대응되는-method"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-crud에-대응되는-method"}},[t._v("#")]),t._v(" 4. CRUD에 대응되는 Method")]),t._v(" "),s("p",[t._v("GET, POST, PUT, DELETE")]),t._v(" "),s("h2",{attrs:{id:"_5-멱등성을-가지는-method"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-멱등성을-가지는-method"}},[t._v("#")]),t._v(" 5. 멱등성을 가지는 Method")]),t._v(" "),s("ul",[s("li",[t._v("멱등성 : 여러번 연산해도 결과가 달라지지 않는 성질")])]),t._v(" "),s("p",[t._v("GET, HEAD와 같이 서버측의 상태 정보를 변경하지 않는 메소드")]),t._v(" "),s("h2",{attrs:{id:"_6-stateless와-stateful"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-stateless와-stateful"}},[t._v("#")]),t._v(" 6. Stateless와 Stateful")]),t._v(" "),s("h3",{attrs:{id:"stateless"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#stateless"}},[t._v("#")]),t._v(" Stateless")]),t._v(" "),s("p",[t._v("대표적인 Stateless 프로토콜로는 UDP와 HTTP가 있다."),s("br"),t._v("\n세션 상태에 관계 없이 단순히 데이터그램을 source에서 destination 쪽으로 전송한다."),s("br"),t._v("\nClient가 송신하려 했던 모든 데이터가 server쪽에 수신되었는지 확인하지 않는다. 따라서 server쪽은 Client와의 세션 정보를 전혀 저장하지 않는다.")]),t._v(" "),s("ul",[s("li",[t._v("세션 정보를 server에 저장하지 않음. 세션 상태에 무관한 응답\n"),s("ul",[s("li",[t._v("따라서 스케일링에 용이하다")])])])]),t._v(" "),s("h3",{attrs:{id:"stateful"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#stateful"}},[t._v("#")]),t._v(" Stateful")]),t._v(" "),s("p",[t._v("대표적인 Stateful 프로토콜로는 TCP가 있다."),s("br"),t._v("\nTCP의 3way handshaking과정을 생각해보면, Server와 Client는 3way handshaking 과정에서 SYN과 SYN/ACK을 주고 받으며 양단간 세션 상태를 정해진 '상태'로 만든다."),s("br"),t._v("\n세션 상태가 정해지면 client와 server는 데이터를 주고 받을 수 있다."),s("br"),t._v("\nTCP는 세션 상태에 따라 server 응답이 달라지는 stateful 프로토콜이다.")]),t._v(" "),s("ul",[s("li",[t._v("세션 정보를 server에 저장, 세션 상태에 따른 응답 을 만족하도록 설계된 서비스 구조")])]),t._v(" "),s("h2",{attrs:{id:"_7-session과-cookie"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-session과-cookie"}},[t._v("#")]),t._v(" 7. Session과 Cookie")]),t._v(" "),s("p",[t._v("HTTP 프로토콜의 특징이자 약점을 보완하기 위해 사용된다.")]),t._v(" "),s("ol",[s("li",[t._v("Connectionless 프로토콜\n클라이언트가 서버에 요청을 했을 때, 그 요청에 맞는 응답을 보낸 후 연결을 끊는 처리 방식\n(단, HTTP 1.1 에서 "),s("code",[t._v("keep-alive")]),t._v(" 값으로 연결을 유지하고 재활용 하는 기능이 추가 됨)")]),t._v(" "),s("li",[t._v("Stateless 프로토콜\n클라이언트의 상태 정보를 가지지 않는 서버 처리 방식. 클라이언트와 첫번째 통신에서 데이터를 주고 받았다고 해도, 두번째 통신에서 이전 데이터를 유지 하지 않는다.")])]),t._v(" "),s("p",[t._v("그러나 실제로는 데이터 유지가 필요한 경우가 많아서, 둘다 웹 통신간 유지하려는 정보(로그인 정보 등)를 저장하기 위해 사용 된다.")]),t._v(" "),s("h3",{attrs:{id:"session"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#session"}},[t._v("#")]),t._v(" Session")]),t._v(" "),s("p",[t._v("일정 시간 동안 같은 사용자(브라우저)로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 일정하게 유지시키는 기술이다. (일정 시간이란, 웹 서버에 접속한 시점부터 웹 브라우저를 종료하여 연결을 끝내는 시점을 의미) 예를 들어 화면을 이동해도 로그인이 풀리지 않고 로그아웃전까지 유지")]),t._v(" "),s("ul",[s("li",[t._v("웹 서버에 웹 컨테이너의 상태를 유지하기 위한 정보를 저장한다.")]),t._v(" "),s("li",[t._v("브라우저를 닫거나, 서버에서 세션을 삭제했을 때만 삭제가 되므로, 쿠키보다 비교적 보안이 좋다")]),t._v(" "),s("li",[t._v("저장 데이터에 제한이 없다. (서버가 허락하는 한)")]),t._v(" "),s("li",[t._v("각 클라이언트 고유의 Session ID를 부여한다.")])]),t._v(" "),s("h4",{attrs:{id:"session의-동작순서"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#session의-동작순서"}},[t._v("#")]),t._v(" Session의 동작순서")]),t._v(" "),s("ol",[s("li",[t._v("클라이언트가 페이지를 요청")]),t._v(" "),s("li",[t._v("서버는 접근한 클라이언트의 Request-Header 필드인 Cookie를 확인하여, 클라이언트가 해당 session id를 보냈는지 확인")]),t._v(" "),s("li",[t._v("session id가 존재하지 않는다면, 서버는 session id를 생성해 클라이언트에게 반환")]),t._v(" "),s("li",[t._v("서버에서 클라이언트로 돌려준 session id를 쿠키를 사용해 서버에 저장")]),t._v(" "),s("li",[t._v("클라이언트는 재접속시, 이 쿠키를 이용하여 session-id 값을 서버에 전달")])]),t._v(" "),s("h3",{attrs:{id:"cookie"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cookie"}},[t._v("#")]),t._v(" Cookie")]),t._v(" "),s("p",[t._v("사용자가 어떠한 웹 사이트를 방문할 경우, 그 사이트가 사용하고 있는 서버에서 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일."),s("br"),t._v("\nHTTP에서 클라이언트의 상태 정보를 클라이언트 PC에 저장하였다가 필요시 정보를 참조하거나 재사용 가능.")]),t._v(" "),s("ul",[s("li",[t._v("이름, 값, 만료일(저장 기간), 경로 정보로 구성")]),t._v(" "),s("li",[t._v("클라이언트에 총 300개의 쿠키 저장 가능")]),t._v(" "),s("li",[t._v("하나의 도메인당 20개의 쿠키를 가질 수 있음")]),t._v(" "),s("li",[t._v("하나의 쿠키는 4KB까지 저장 가능 하다")])]),t._v(" "),s("h4",{attrs:{id:"cookie의-동작순서"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cookie의-동작순서"}},[t._v("#")]),t._v(" Cookie의 동작순서")]),t._v(" "),s("ol",[s("li",[t._v("클라이언트가 페이지를 요청")]),t._v(" "),s("li",[t._v("웹 서버가 쿠키 생성")]),t._v(" "),s("li",[t._v("생성한 쿠키에 정보에 담아 HTTP 화면을 돌려줄 때, 같이 클라이언트에 반환")]),t._v(" "),s("li",[t._v("넘겨 받은 쿠키는 클라이언트가 로컬 PC에 저장하여 가지고 있다가, 다시 서버가 요청할 때 요청과 함께 쿠키를 전송")]),t._v(" "),s("li",[t._v("동일 사이트 재방문시 클라이언트 PC에 해당 쿠키가 있는 경우, 요청 페이지와 함께 쿠키를 전송")])]),t._v(" "),s("h2",{attrs:{id:"_8-request-response"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-request-response"}},[t._v("#")]),t._v(" 8. Request/Response")]),t._v(" "),s("h3",{attrs:{id:"request"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#request"}},[t._v("#")]),t._v(" Request")]),t._v(" "),s("p",[t._v("HTTP Request는 서버에서 데이터를 처리하기 위한 또는 가져오기 위한 메시지이다.")]),t._v(" "),s("ol",[s("li",[t._v("Start Line")])]),t._v(" "),s("ul",[s("li",[t._v("HTTP Method")]),t._v(" "),s("li",[t._v("Request Target")]),t._v(" "),s("li",[t._v("HTTP Version")])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("Header")])]),t._v(" "),s("ul",[s("li",[t._v("Key: value")])]),t._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[t._v("Body")])]),t._v(" "),s("ul",[s("li",[t._v("해당 요청의 실제 내용")])]),t._v(" "),s("h3",{attrs:{id:"response"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#response"}},[t._v("#")]),t._v(" Response")]),t._v(" "),s("ol",[s("li",[t._v("Start Line")])]),t._v(" "),s("ul",[s("li",[t._v("HTTP Version")]),t._v(" "),s("li",[t._v("Status Code")]),t._v(" "),s("li",[t._v("Status Text")])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[s("p",[t._v("Headers")])]),t._v(" "),s("li",[s("p",[t._v("Body")])])]),t._v(" "),s("h2",{attrs:{id:"_9-multipart란"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-multipart란"}},[t._v("#")]),t._v(" 9. Multipart란")]),t._v(" "),s("p",[t._v("MIME 타입 중 하나로서, 웹 클라이언트가 요청을 보낼 때, http 프로토콜의 바디 부분에 데이터를 여러부분으로 나눠서 보내는 것.")]),t._v(" "),s("h2",{attrs:{id:"_10-로그인-프로세스"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-로그인-프로세스"}},[t._v("#")]),t._v(" 10. 로그인 프로세스")]),t._v(" "),s("p",[t._v("ID 평문, PW 비대칭 암호화 알고리즘을 써서 해싱처리. sha256.\nform id, pw\nhttp post -> content type x-form-encoded\n서버는 id를 기준으로 db . 유니크키로\npw는 body로 받은 패스워\n애플리케이션에서 해싱 암호화 = 암호 패싱 된거 확인\nretry count")])])}),[],!1,null,null,null);e.default=r.exports}}]);